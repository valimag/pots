%% @doc Модуль `rss_queue` представляет собой сервер очереди RSS-лент, реализованный с помощью поведения `gen_server`.
-module(rss_queue).

%% @doc Компилируем модуль с экспортом всех функций.
-compile(export_all).

%% @doc Определение тайм-аута в миллисекундах для операций, требующих ожидания.
-define(TIMEOUT, 10000).

%% @doc Подключение заголовочных файлов для логирования и работы с XML и HTTP.
-include("logging.hrl").
-include("C:/Program Files/erl6.1/lib/xmerl-1.3.7/include/xmerl.hrl").
-include("C:/Program Files/erl6.1/lib/inets-5.10.2/include/httpd.hrl").

%% @doc Объявление, что модуль реализует поведение `gen_server`.
%% Проверяет, что модуль содержит все необходимые функции, которые есть в gen_server
-behaviour(gen_server).

%% @doc Экспорт функций для обратного вызова (callback), требуемых поведением `gen_server`.
-export([
  init/1, 
  handle_call/3, 
  handle_cast/2, 
  handle_info/2, 
  terminate/2,
  code_change/3
  ]).

%% @doc Экспорт дополнительных функций модуля.
-export([start/1]).

%% @doc Определение записи состояния сервера, включающей очередь сообщений и список подписчиков.
%% rssQ = {queue, subscribers}
-record(rssQ, {queue, subscribers}).

%% @doc Функция `start/1` запускает новый gen_server с локальным именем.
%% @param Name Имя сервера, под которым он будет зарегистрирован.
start(Name) -> 
  %% Запускает gen_server с указанным локальным именем, без начальных аргументов.
  %% gen_server:start(ServerName, Module, Args, Options) - функция запуска
  %% {local, Name}: Опция, указывающая, что сервер должен быть запущен с локальным именем Name.
  %% ?MODULE: Имя модуля, в котором определена функция start, чтобы указать gen_server, где искать реализацию сервера.
  %% Module - указывает на модуль обратного вызова
  %% Args = [] это произвольный терм, передаваемый функции обратного вызова Module:init/1
  %% Options = [] это настройки gen_server
  gen_server:start({local, Name}, ?MODULE, [], []).

%% @doc Функция `start/2` запускает новый gen_server с локальным именем и URL.
%% @param Name Имя сервера, под которым он будет зарегистрирован.
%% @param Url URL RSS-ленты, который будет использоваться для инициализации сервера.
start(Name, Url)->
  %% Запускает gen_server с указанным локальным именем, без начальных аргументов.
  %% gen_server:start(ServerName, Module, Args, Options) - функция запуска
  %% {local, Name}: Опция, указывающая, что сервер должен быть запущен с локальным именем Name.
  %% ?MODULE: Имя модуля, в котором определена функция start, чтобы указать gen_server, где искать реализацию сервера.
  %% Module - указывает на модуль обратного вызова
  %% Args = [Url] это произвольный терм, передаваемый функции обратного вызова Module:init/1
  %% Options = [] это настройки gen_server
  gen_server:start({local, Name}, ?MODULE, [Url], []).

%% @doc Функция `init/1` инициализирует состояние сервера.
%% @param Args Список аргументов, переданных при запуске сервера.
%% Запускает очередь в "автономном" режиме
init([]) ->
  %% Устанавливаем флаг process_flag, чтобы процесс перехватывал сообщения о завершении связанных процессов.
  %% Для надежной обработки сигналов ненормального завершения, надо перехватывать все сигналы выхода
  %% Устанавливает флаг trap_exit для процесса, чтобы он перехватывал сообщения о завершении связанных процессов. 
  process_flag(trap_exit, true),
  %% Инициализируем состояние сервера с пустой очередью и новым набором подписчиков.
  {ok, #rssQ{queue=[], subscribers=sets:new()}};

%% Обрабатывается случай, когда init получает список с URL.
%% Получает URL, и запускает очередь в режиме "чтения".
init([Url]) -> 
  %% Создаем начальное состояние сервера с пустой очередью и новым набором подписчиков.
  State = #rssQ{queue=[], subscribers=sets:new()},
  %% Устанавливаем флаг process_flag, как и в предыдущем случае.
  process_flag(trap_exit, true),
  %% Запускаем rss_reader для чтения RSS-ленты по переданному URL.
  rss_reader:start(Url, self()),
  %% Возвращаем состояние сервера для дальнейшей работы.
  {ok, State}.

%% @doc Обрабатывает вызовы к серверу.
%% `handle_call` используется для обработки синхронных запросов.
%% синхронные, потому что они блокируют вызывающий процесс до тех пор, 
%% пока не завершится их выполнение и не будет возвращен результат.

%% Обрабатывает запрос на подписку нового подписчика.
%% Параметры handle_call: Request, From, State
%% Request передает запросы модулю обратного вызова
%% From это кортеж {Pid, Tag}
%% State это текущее состояние сервера
%% QPid - идентификатор процесса, который хочет подписаться на очередь.
handle_call(_Request={subscribe, QPid}, _From, State=#rssQ{queue=Q, subscribers=Subs}) ->
  %% Проверяем, является ли процесс уже подписчиком.
  {Reply, NewState} = case sets:is_element(QPid, Subs) of
    true -> 
      %% Если уже подписан, возвращаем ошибку.
      {{error, already_subscribed}, State};
    false ->  
      %% Если нет, мониторим процесс подписчика.
      %% Создаем однонаправленную связь с другим процессом
      erlang:monitor(process, QPid),
      %% Логируем новую подписку.
      %% ?INFO - это макрос, который используется для записи сообщений журнала или логирования информации.
      %% передает "информационное" сообщение сервису ведения журнала, автоматически вставляя в текст имя модуля и PID процесса передающего сообщение.
      ?INFO("New subscriber ~p to ~p~n", [QPid, self()]),
      %% Добавляем все текущие элементы очереди подписчику.
      %% Для каждого элемента в текущей очереди Q вызывается функция add_item(QPid, Item), 
      %% которая добавляет этот элемент процессу-подписчику.
      [add_item(QPid, Item) || Item <- Q],
      %% Возвращаем обновленное состояние с добавленным подписчиком.
      %% Обновленный набор подписчиков добавляется к состоянию сервера, и возвращается новое состояние с добавленным подписчиком.
      {ok, State#rssQ{subscribers=sets:add_element(QPid, Subs)}}
  end,
  %% Отвечаем на запрос.
  %% это либо {error, already_subscribed}, если процесс уже был подписан, 
  %%либо ok, если подписка успешно добавлена, а NewState - это обновленное состояние сервера.
  {reply, Reply, NewState};

%% Обрабатывает запрос на получение всех элементов.
%% Параметры handle_call: Request, From, State
%% Request передает запросы модулю обратного вызова
%% From это кортеж {Pid, Tag}
%% State это текущее состояние сервера
%% QPid - идентификатор процесса, который хочет подписаться на очередь.
handle_call(_Request={get_all}, _From, State=#rssQ{queue=Q}) -> 
  %% Возвращаем все элементы очереди и текущее состояние.
  {reply, Q, State};

%% Обрабатывает неизвестные запросы.
%% Параметры handle_call: Request, From, State
%% Request передает запросы модулю обратного вызова
%% From это кортеж {Pid, Tag}
%% State это текущее состояние сервера
%% QPid - идентификатор процесса, который хочет подписаться на очередь.
handle_call(_Request, _From, State) -> 
  %% Возвращаем ошибку с указанием неизвестного запроса.
  {reply, {error, {unknown_request, _Request}}, State}.

%% @doc Обрабатывает асинхронные сообщения (без ожидания ответа).
%% Не ожидает ответа от других процессов или внешних источников данных, 
%% а просто продолжает свою работу независимо от того, завершились ли эти действия успешно или нет.

%% Обрабатывает добавление нового элемента RSS в очередь.
handle_cast(_Msg={add_item, RSSItem=#xmlElement{name=item}}, State=#rssQ{queue=Q, subscribers=Subs}) ->
  %% Добавляет элемент в очередь и обновляет список подписчиков.
  NewQ = add_item_to_q(RSSItem, Q, Subs), % Вызов функции для добавления элемента
  %% в ответ на полученное сообщение сервер не отправляет никакого ответа (noreply), 
  %% а лишь обновляет своё состояние, заменяя текущую очередь на новую с добавленным элементом.
  {noreply, State#rssQ{queue=NewQ}}; % Возвращает обновленное состояние без ответа

%% Обрабатывает запрос на отмену подписки.
handle_cast(_Msg={unsubscribe, QPid}, State=#rssQ{subscribers=Subs}) -> 
  %% Удаляет PID процесса из списка подписчиков.
  {noreply, State#rssQ{subscribers=sets:del_element(QPid, Subs)}}; % Обновляет список подписчиков, удаляя отписавшийся процесс

%% Обрабатывает неизвестные сообщения.
handle_cast(_Msg, State) -> 
  %% Выводит предупреждение о получении неизвестного сообщения.
  ?WARN("Unknown msg {~p} to Q{~p}", [_Msg, State]), % Логирует неизвестное сообщение и состояние сервера
  {noreply, State}. % Возвращает текущее состояние без изменений

%% @doc Обрабатывает информационные сообщения, включая системные события.
%% Обрабатывает сигнал выхода из связанного процесса

%% Обрабатывает событие завершения работы связанного процесса.
%% _Info={'DOWN', _, _, QPid, _Reason}: Это сопоставление с образцом, которое проверяет, 
%% является ли полученное информационное сообщение кортежом, содержащим атом 'DOWN'
%% _Reason - Знак подчеркивания (_) используется для игнорирования дополнительных значений, 
%% которые могут быть содержаться в сообщении о завершении.
%% мониторящий процесс получает сообщение: {'DOWN', Ref, process, Pid, Reason}
handle_info(_Info={'DOWN', _, _, QPid, _Reason}, State=#rssQ{subscribers=Subs})->
  %% Удаляет процесс из списка подписчиков.
  {noreply, State#rssQ{subscribers=sets:del_element(QPid, Subs)}}; % Обновляет состояние, удаляя PID завершенного процесса из подписчиков

%% Обрабатывает сообщение об ошибке при завершении работы процесса RSS Reader.
%% _Info={'EXIT', FromPid, _Reason}: Это сопоставление с образцом, которое проверяет, 
%% является ли полученное информационное сообщение кортежом, содержащим атом 'EXIT'.
%% FromPid представляет PID (идентификатор процесса), который завершился с ошибкой, 
%% _Reason содержат дополнительную информацию о причине завершения.
handle_info(_Info={'EXIT', FromPid, _Reason}, State)->
  %% Логирует ошибку с указанием PID процесса и причины его завершения.
  ?ERROR("RSS Reader ~p died for ~p with reason ~n", [FromPid, self(), _Reason]),
  {noreply, State}; % Возвращает текущее состояние без изменений

%% Обрабатывает все остальные информационные сообщения.
handle_info(_Info, State) -> 
  %% Просто возвращает текущее состояние без изменений.
  {noreply, State}. % Игнорирует сообщение и продолжает работу без изменений состояния

%% @doc Функции, относящиеся к завершению работы сервера, изменению кода и подписке на обновления.

%% Функция вызывается при завершении работы сервера.
%% Значение возвращаемое terminate не используется
terminate(_Reason, _State) -> 
  %% Просто возвращает атом 'ok', не выполняя никаких действий.
  ok.

%% Функция вызывается при обновлении кода сервера.
%% Обрабатывает обновления кода на работающем сервере
code_change(_OldVsn, State, _Extra) -> 
  %% Возвращает текущее состояние сервера с атомом 'ok', не внося изменений.
  {ok, State}.

%% Функция для подписки одной очереди на обновления другой.
subscribe(From, To)->
  %% Вызывает функцию обратного вызова на сервере 'To' с сообщением о подписке.
  %% gen_server:call(ServerRef, Request) Реализует синхронную передачу запросов/ответов сервера
  gen_server:call(To, {subscribe, From}). % Возвращает результат вызова функции обратного вызова.

%% @doc Добавление элементов в очередь и их трансляция подписчикам.

%% Добавляет новый элемент в очередь.
%% @param NewItem Новый элемент для добавления.
%% @param Q Текущая очередь элементов.
%% @param Subs Список подписчиков на очередь.
add_item_to_q(NewItem, Q, Subs)->
  %% Вызывает рекурсивную вспомогательную функцию с пустым аккумулятором.
  add_item_to_q(NewItem, [], Q, Subs).

%% Вспомогательная функция для добавления элемента в очередь.
%% @param NewItem Новый элемент для добавления.
%% @param L1 Аккумулятор для рекурсивного сбора элементов.
%% @param [] Пустой список, означающий окончание текущей очереди.
%% @param Subs Список подписчиков на очередь.
add_item_to_q(NewItem, L1, [], Subs)->
  %% Логирует добавление нового элемента.
  ?INFO("New item ~p ~n", [self()]),
  %% Рассылает новый элемент всем подписчикам.
  broadcast(NewItem, Subs),
  %% Возвращает новую очередь с добавленным элементом.
  L1++[NewItem];

%% Обработка добавления элемента в непустую очередь.
%% @param NewItem Новый элемент для добавления.
%% @param L1 Аккумулятор для рекурсивного сбора элементов.
%% @param L Текущая очередь элементов.
%% @param Subs Список подписчиков на очередь.
add_item_to_q(NewItem, L1, L = [OldItem | Rest], Subs)->
  %% Сравнивает новый и старый элементы.
  case rss_parse:compare_feed_items(OldItem, NewItem) of
    same -> 
      %% Возвращает неизменную очередь, если элементы одинаковы.
      L1++L;
    updated -> 
      %% Обновляет элемент в очереди и оповещает подписчиков.
      ?INFO("Updated item ~p ~n", [self()]),
      broadcast(NewItem, Subs),
      L1++Rest++[NewItem];
    different -> 
      %% Продолжает поиск места для нового элемента в очереди.
      add_item_to_q(NewItem, L1++[OldItem], Rest, Subs)
  end.

%% Добавляет новый элемент в очередь, асинхронно сообщая серверу.
%% @param QPid Идентификатор процесса очереди.
%% @param Item Элемент для добавления.
add_item(QPid, Item)->
  %% Отправляет сообщение серверу для асинхронного добавления элемента.
  ok = gen_server:cast(QPid, {add_item, Item}), ok.

%% @doc Добавляет элементы из RSS-ленты в очередь и транслирует их подписчикам.

%% Добавляет элементы из RSS-ленты в указанную очередь.
%% @param QPid Идентификатор процесса очереди, куда добавляются элементы.
%% @param RSS2Feed RSS-лента, из которой извлекаются элементы.
add_feed(QPid, RSS2Feed)->
  %% Получение списка элементов из RSS-ленты.
  Items = rss_parse:get_feed_items(RSS2Feed),
  %% Добавление каждого элемента из списка в очередь.
  [add_item(QPid, Item) || Item <- Items],
  %% Логирование количества добавленных элементов.
  ?INFO("Added N=~p items from the feed to ~p ~n", [length(Items), QPid]),
  ok.

%% Запрашивает все элементы из указанной очереди.
%% @param QPid Идентификатор процесса очереди, из которой запрашиваются элементы.
%% @return Возвращает список всех элементов из очереди.
get_all(QPid)->
  %% Отправка синхронного запроса на получение всех элементов из очереди.
  %% ServerRef, Request
  gen_server:call(QPid, {get_all}).

%% Рассылает новый элемент всем подписчикам.
%% @param Item Новый элемент, который нужно рассылать подписчикам.
%% @param PidSet Набор идентификаторов процессов подписчиков.
broadcast(Item, PidSet)->
  %% Для каждого подписчика вызывается функция add_item, которая добавляет новый элемент в их очереди.
  %% || - это оператор списка включений (list comprehension), который позволяет создавать списки на основе других списков
  [add_item(Pid, Item) || Pid <- sets:to_list(PidSet)]. 

%% @doc Тестирование функциональности сервера очереди RSS.
%% Эта функция тестирует добавление элементов из RSS-ленты в очередь, подписку одной очереди на другую,
%% и корректность передачи элементов между очередями.

test() ->
    %% Открытие файла для записи результатов тестирования. Результаты будут записаны в файл "testing.txt".
    {ok, FileHandle} = file:open("testing.txt", [write]),
    
    %% Сохраняем текущий group leader процесса. Это необходимо для того, чтобы восстановить его после тестирования.
    OldGroupLeader = group_leader(),
    %% Изменяем group leader на файловый дескриптор, чтобы вывод io:format направлялся в файл.
    group_leader(FileHandle, self()),

    %% Выводим сообщение о начале тестирования в файл.
    io:format("Starting RSS Queue Server Test...~n"),

    %% Запускаем два сервера очереди RSS. Один считывает ленту из локального файла, второй - из URL.
    start(queue1, "digg-science-rss1.xml"),
    start(queue2, "http://rss.cnn.com/rss/cnn_topstories.rss"),
    
    %% Даем время на инициализацию и загрузку лент.
    timer:sleep(1000),

    %% Подписываем вторую очередь на обновления первой.
    rss_queue:subscribe(queue2, queue1),
    %% Фиксируем в файле факт подписки.
    io:format("Queue 2 subscribed to Queue 1.~n"),

    %% Восстанавливаем первоначальный group leader, закрываем файл с результатами тестирования и останавливаем все очереди.
    group_leader(OldGroupLeader, self()),
    file:close(FileHandle),
    ok.